package sfv

import (
	"bytes"
	"io/ioutil"
	"os"
	"path"
	"testing"
	"text/template"
)

const sfv = `
; Generated by BSDSFV for UNiX, $Revision: 1.18 $ on 2014-08-10 at 20:47.28
;
{{.File1}} 7E3265A8
{{.File2}} 04A2B3E9
`

type values struct {
	File1 string
	File2 string
}

func tempFile(content string) (*os.File, error) {
	f, err := ioutil.TempFile("", "gosfv")
	if err != nil {
		return nil, err
	}
	b := []byte(content)
	if err := ioutil.WriteFile(f.Name(), b, 0600); err != nil {
		return nil, err
	}
	return f, err
}

func createSFVFile() (*os.File, error) {
	f1, err := tempFile("foo\n")
	if err != nil {
		return nil, err
	}
	f2, err := tempFile("bar\n")
	if err != nil {
		return nil, err
	}
	values := values{
		File1: path.Base(f1.Name()),
		File2: path.Base(f2.Name()),
	}
	var b bytes.Buffer
	t := template.Must(template.New("sfv").Parse(sfv))
	if err := t.Execute(&b, values); err != nil {
		return nil, err
	}
	sfvFile, err := tempFile(b.String())
	if err != nil {
		return nil, err
	}
	return sfvFile, nil
}

func TestParseChecksum(t *testing.T) {
	line := "foo 7E3265A8"
	checksum, err := ParseChecksum("/tmp", line)
	if err != nil {
		t.Fatal(err)
	}
	if expected := "/tmp/foo"; checksum.Path != expected {
		t.Fatalf("Expected %s, got %s", expected, checksum.Path)
	}
	if expected := uint32(2117232040); checksum.CRC32 != expected {
		t.Fatalf("Expected %s, got %s", expected, checksum.CRC32)
	}
}

func TestParseChecksumWhitespace(t *testing.T) {
	line := "foo     \t7E3265A8"
	checksum, err := ParseChecksum("/tmp", line)
	if err != nil {
		t.Fatal(err)
	}
	if expected := "/tmp/foo"; checksum.Path != expected {
		t.Fatalf("Expected %s, got %s", expected, checksum.Path)
	}
	if expected := uint32(2117232040); checksum.CRC32 != expected {
		t.Fatalf("Expected %s, got %s", expected, checksum.CRC32)
	}
}

func TestRead(t *testing.T) {
	f, err := createSFVFile()
	if err != nil {
		t.Fatal(err)
	}
	sfv, err := Read(f.Name())
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		for _, c := range sfv.Checksums {
			os.Remove(c.Path) // Ignore error
		}
		os.Remove(sfv.Path) // Ignore error
	}()
	if path := f.Name(); sfv.Path != path {
		t.Fatalf("Expected %s, got %s", path, sfv.Path)
	}
	if exist := sfv.IsExist(); !exist {
		t.Fatal("Expected true, got false")
	}
	ok, err := sfv.Verify()
	if err != nil {
		t.Fatal(err)
	}
	if !ok {
		t.Fatal("Expected true, got false")
	}
}
