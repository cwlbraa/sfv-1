package sfv

import (
	"bytes"
	"io/ioutil"
	"os"
	"path"
	"testing"
	"text/template"
)

const sfv = `
; Generated by BSDSFV for UNiX, $Revision: 1.18 $ on 2014-08-10 at 20:47.28
;
{{.File1}} 7E3265A8
{{.File2}} 04A2B3E9
`

type values struct {
	File1 string
	File2 string
}

func tempFile(content string) (*os.File, error) {
	f, err := ioutil.TempFile("", "gosfv")
	if err != nil {
		return nil, err
	}
	b := []byte(content)
	if err := ioutil.WriteFile(f.Name(), b, 0600); err != nil {
		return nil, err
	}
	return f, err
}

func createSFVFile() (*os.File, error) {
	f1, err := tempFile("foo\n")
	if err != nil {
		return nil, err
	}
	f2, err := tempFile("bar\n")
	if err != nil {
		return nil, err
	}
	values := values{
		File1: path.Base(f1.Name()),
		File2: path.Base(f2.Name()),
	}
	var b bytes.Buffer
	t := template.Must(template.New("sfv").Parse(sfv))
	if err := t.Execute(&b, values); err != nil {
		return nil, err
	}
	sfvFile, err := tempFile(b.String())
	if err != nil {
		return nil, err
	}
	return sfvFile, nil
}

func TestRead(t *testing.T) {
	f, err := createSFVFile()
	if err != nil {
		t.Fatal(err)
	}
	sfv, err := Read(f.Name())
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if sfv != nil {
			for _, c := range sfv.Checksums {
				if err := os.Remove(c.Path); err != nil {
					t.Fatal(err)
				}
			}
		}
		if err := os.Remove(f.Name()); err != nil {
			t.Fatal(err)
		}
	}()

	ok, err := sfv.Verify()
	if err != nil {
		t.Fatal(err)
	}
	if !ok {
		t.Fatal("Expected true, got false")
	}
}
