package sfv

import (
	"bytes"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"strings"
	"testing"
	"text/template"
)

const sfv = `
; Generated by BSDSFV for UNiX, $Revision: 1.18 $ on 2014-08-10 at 20:47.28
;
{{.File1}} 7E3265A8
{{.File2}} 04A2B3E9
`

type values struct {
	File1 string
	File2 string
}

func tempFile(content string) (*os.File, error) {
	f, err := ioutil.TempFile("", "gosfv")
	if err != nil {
		return nil, err
	}
	b := []byte(content)
	if err := ioutil.WriteFile(f.Name(), b, 0600); err != nil {
		return nil, err
	}
	return f, err
}

func createSFVFile() (*os.File, error) {
	f1, err := tempFile("foo\n")
	if err != nil {
		return nil, err
	}
	f2, err := tempFile("bar\n")
	if err != nil {
		return nil, err
	}
	values := values{
		File1: path.Base(f1.Name()),
		File2: path.Base(f2.Name()),
	}
	var b bytes.Buffer
	t := template.Must(template.New("sfv").Parse(sfv))
	if err := t.Execute(&b, values); err != nil {
		return nil, err
	}
	sfvFile, err := tempFile(b.String())
	if err != nil {
		return nil, err
	}
	return sfvFile, nil
}

func TestParseChecksum(t *testing.T) {
	line := "foo 7E3265A8"
	checksum, err := parseChecksum("/tmp", line)
	if err != nil {
		t.Fatal(err)
	}
	if expected := "/tmp/foo"; checksum.Path != expected {
		t.Fatalf("Expected %s, got %s", expected, checksum.Path)
	}
	if expected := uint32(2117232040); checksum.CRC32 != expected {
		t.Fatalf("Expected %d, got %d", expected, checksum.CRC32)
	}
}

func TestParseChecksums(t *testing.T) {
	in := "; comment\n" +
		"file1  7E3265A8\n" +
		"file2 04A2B3E7\r\n" +
		"file3 04A2B3E9\n" +
		"file4 \t04A2B3E6"
	out := []Checksum{
		Checksum{Path: "/tmp/file1", Filename: "file1", CRC32: 2117232040},
		Checksum{Path: "/tmp/file2", Filename: "file2", CRC32: 77771751},
		Checksum{Path: "/tmp/file3", Filename: "file3", CRC32: 77771753},
		Checksum{Path: "/tmp/file4", Filename: "file4", CRC32: 77771750},
	}
	checksums, err := parseChecksums("/tmp", strings.NewReader(in))
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(checksums, out) {
		t.Fatalf("Expected %+v, got %+v", out, checksums)
	}
}

func TestRead(t *testing.T) {
	f, err := createSFVFile()
	if err != nil {
		t.Fatal(err)
	}
	sfv, err := Read(f.Name())
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		for _, c := range sfv.Checksums {
			os.Remove(c.Path) // Ignore error
		}
		os.Remove(sfv.Path) // Ignore error
	}()
	if path := f.Name(); sfv.Path != path {
		t.Fatalf("Expected %s, got %s", path, sfv.Path)
	}
	if exist := sfv.IsExist(); !exist {
		t.Fatal("Expected true, got false")
	}
	ok, err := sfv.Verify()
	if err != nil {
		t.Fatal(err)
	}
	if !ok {
		t.Fatal("Expected true, got false")
	}
}

func TestFind(t *testing.T) {
	dir, err := ioutil.TempDir("", "gosfv")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(dir)

	// No SFV file in dir should result in error
	if _, err := Find(dir); err == nil {
		t.Fatal("Expected error")
	}
	filepath := filepath.Join(dir, "test.sfv")
	if err := ioutil.WriteFile(filepath, []byte{}, 0600); err != nil {
		t.Fatal(err)
	}
	sfv, err := Find(dir)
	if err != nil {
		t.Fatal(err)
	}
	if sfv.Path != filepath {
		t.Fatalf("Expected %q, got %q", filepath, sfv.Path)
	}
}

func TestEmptySFV(t *testing.T) {
	sfv := SFV{Path: "/tmp/sfv.sfv"}
	if _, err := sfv.Verify(); err == nil {
		t.Fatal("Expected error")
	}
}
